import fetch from "node-fetch";
import Repo from "../models/Repo.js";
import detectTechStack from "../utils/techDetector.js";

// --- Import LangChain and OpenAI ---
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";
import { StringOutputParser } from "@langchain/core/output_parsers";
import "dotenv/config"; // Loads .env variables

// --- Initialize OpenAI Model and Chain ---

// Check for API key
if (!process.env.OPENAI_API_KEY) {
  console.error("OPENAI_API_KEY is not set. Please create a .env file.");
}

// 1. Initialize the AI Model
const model = new ChatOpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  modelName: "gpt-4o",
  temperature: 0.1,
});

// 2. Create a Prompt Template
const dockerfilePrompt = PromptTemplate.fromTemplate(
  `You are a senior DevOps expert. Your task is to generate a concise, production-ready Dockerfile for a project.

Project Tech Stack Details:
{techStack}

Instructions:
1.  Use official, minimal base images (e.g., 'node:20-alpine', 'nginx:alpine').
2.  Use multi-stage builds to keep the final image small.
3.  If it's a frontend project, serve the static build output (e.g., 'build' or 'dist') with Nginx.
4.  If it's a backend project, correctly install dependencies (use '--production' in the final stage), expose the port (assume 3000 if not specified), and set the correct 'CMD'.
5.  Provide *only* the Dockerfile content as a raw text string.
6.  Do NOT include any explanations, markdown (\`\`\`dockerfile), or "Here is your Dockerfile:" text. Only output the code.
`
);

// 3. Create a simple chain: Prompt -> Model -> Output Parser
const chain = dockerfilePrompt.pipe(model).pipe(new StringOutputParser());

// -----------------------------  Generate Dockerfile -----------------------------
export const generateDockerfile = async (req, res) => {
  try {
    const { repoUrl, token } = req.body;
    console.log("Processing repository:", repoUrl);

    const urlMatch = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!urlMatch) {
      throw new Error("Invalid GitHub repository URL");
    }

    const [, owner, repo] = urlMatch;
    const repoName = repo.replace(".git", "");

    // ----------------------------- Fetch repo contents -----------------------------
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repoName}/contents`,
      {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      const errText = await response.text();
      console.error("GitHub API error:", errText);
      throw new Error(
        `Failed to fetch repository: ${response.statusText} (${response.status})`
      );
    }
    const contents = await response.json();

    //  ----------------------------- Fetch package.json if available-----------------------------
    let packageJson = null;
    const pkgFile = contents.find((f) => f.name === "package.json");
    if (pkgFile) {
      const pkgResponse = await fetch(pkgFile.download_url);
      if (pkgResponse.ok) {
        packageJson = await pkgResponse.json();
      } else {
        console.warn("Could not fetch package.json, proceeding without it.");
      }
    }

    //  ----------------------------- Getting the techStack  -----------------------------
    const techStack = detectTechStack(contents, packageJson);
    console.log("Detected tech stack:", techStack);

    // --- UPDATED: Generate Dockerfile using LangChain + OpenAI ---
    // This logic is now active.
    // console.log("Calling OpenAI to generate Dockerfile...");
    // const dockerfile = await chain.invoke({
    //   techStack: JSON.stringify(techStack, null, 2),
    // });
    // console.log("Dockerfile generated by AI.");

    // --- This is the old local generation logic, now commented out ---
    const dockerfile = generateLocalDockerfile(techStack);

    // ----------------------------- Save in my MongoDB -----------------------------
    const newRepo = new Repo({ repoUrl, techStack, dockerfile });
    await newRepo.save();

    // Send the final, single response
    res.json({ repoName, techStack, dockerfile });
  } catch (error) {
    console.error("Error generating Dockerfile:", error.message);
    res.status(500).json({ error: error.message });
    return;
  }
};

// ----------------------------- Get all previously generated Dockerfiles  -----------------------------
export const getAllRepos = async (req, res) => {
  try {
    const repos = await Repo.find().sort({ createdAt: -1 });
    res.json(repos);
  } catch (error) {
    res.status(500).json({ error: error.message });
    return;
  }
};

// --- NEW: Function to push the Dockerfile to the GitHub repository ---
export const pushToRepo = async (req, res) => {
  try {
    const { repoUrl, dockerfile, token } = req.body;

    if (!repoUrl || !dockerfile || !token) {
      return res
        .status(400)
        .json({ error: "repoUrl, dockerfile, and token are required." });
    }

    // 1. Parse repo URL
    const urlMatch = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!urlMatch) {
      throw new Error("Invalid GitHub repository URL");
    }
    const [, owner, repo] = urlMatch;
    const repoName = repo.replace(".git", "");
    const apiUrl = `https://api.github.com/repos/${owner}/${repoName}/contents/Dockerfile`;

    // 2. Set headers
    const headers = {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github.v3+json",
      "Content-Type": "application/json",
    };

    // 3. Check if file already exists to get its SHA
    let currentSha = undefined;
    try {
      const getResponse = await fetch(apiUrl, { headers });
      if (getResponse.ok) {
        const fileData = await getResponse.json();
        currentSha = fileData.sha;
        console.log("Dockerfile exists, updating. SHA:", currentSha);
      } else if (getResponse.status !== 404) {
        // If it's not 404, it's a real error (e.g., 401 Unauthorized)
        throw new Error(`Failed to check for file: ${getResponse.statusText}`);
      } else {
        console.log("Dockerfile not found, creating new file.");
      }
    } catch (error) {
      // Handle fetch errors or 404s (which are fine)
      if (!error.message.includes("404")) {
        console.error("Error checking for file:", error.message);
        throw error; // Re-throw real errors
      }
    }

    // 4. Create commit body
    const contentEncoded = Buffer.from(dockerfile).toString("base64");
    const commitMessage = "feat: Add generated Dockerfile by DockGen AI";

    const body = JSON.stringify({
      message: commitMessage,
      content: contentEncoded,
      sha: currentSha, // Will be undefined if file is new, which is correct
    });

    // 5. Make the PUT request to create or update the file
    const putResponse = await fetch(apiUrl, {
      method: "PUT",
      headers,
      body,
    });

    if (!putResponse.ok) {
      const errText = await putResponse.text();
      console.error("GitHub API error on PUT:", errText);
      throw new Error(
        `Failed to push to GitHub: ${putResponse.statusText} (${putResponse.status})`
      );
    }

    const putResult = await putResponse.json();
    console.log("File pushed successfully:", putResult.commit.html_url);

    res.status(201).json({
      message: "Dockerfile pushed successfully!",
      commitUrl: putResult.commit.html_url,
    });
  } catch (error) {
    console.error("Error pushing to repository:", error.message);
    res.status(500).json({ error: error.message });
  }
};

// ----------------------------- Generate the Dockerfiles (LOCAL FALLBACK) -----------------------------
// This function is no longer called by generateDockerfile, but is kept for reference
// -----------------------------------------------------------------------------------------------------

function generateLocalDockerfile(techStack) {
  const { isBackend, packageManager, nodeVersion, hasTypeScript } = techStack;

  console.log(techStack);

  const baseImage = `FROM node:${nodeVersion}-alpine`;

  const workDir = "/app";

  // --- Backend Logic ---

  if (isBackend) {
    if (hasTypeScript) {
      // --- Backend: TypeScript (Multi-stage) ---
      // Assumes build output is in a 'dist' folder
      return `
# 1. Build Stage
${baseImage} AS builder
WORKDIR ${workDir}
COPY package*.json ./
RUN ${packageManager} install
COPY . .
RUN ${packageManager} run build

# 2. Production Stage
${baseImage}
WORKDIR ${workDir}
COPY package*.json ./
RUN ${packageManager} install --production
COPY --from=builder ${workDir}/dist ./dist
EXPOSE 3000
CMD ["node", "dist/index.js"]
`.trim();
    } else {
      // --- Backend: JavaScript ---
      return `
${baseImage}
WORKDIR ${workDir}
COPY package*.json ./
RUN ${packageManager} install --production
COPY . .
EXPOSE 3000
CMD ["${packageManager}", "start"]
`.trim();
    }
  }

  // --- Frontend Logic (Multi-stage) ---
  // Assumes a static build (React, Vue, etc.) that outputs to 'build' or 'dist'
  return `
# 1. Build Stage
${baseImage} AS builder
WORKDIR ${workDir}
COPY package*.json ./
RUN ${packageManager} install
COPY . .
RUN ${packageManager} run build

# 2. Serve Stage (using Nginx)
FROM nginx:alpine
COPY --from=builder ${workDir}/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
`.trim();
}
